<!DOCTYPE html>
<meta charset='utf-8'>
<style>
    .search-wrap {float: left; width: 120px; height: 900px; border: 2px solid #ccc; border-radius: 10px; margin-right: 10px;}
    .search-wrap button {display: block; width: 100%; height: 40px; vertical-align: middle;}

    .search-item-wrap {text-align: center; margin: 10px 0;}

    svg {border: 2px solid #ccc; border-radius: 10px;}
    svg .links path {stroke: #999; stroke-opacity: 1; stroke-width: 2; fill: transparent;}
    svg .nodes use {fill: transparent; cursor: pointer;}
    svg .idTexts text {fill: #bbb;}

    .detail-wrap {width:1000px; height: 85px; margin-left: 134px; border: 2px solid #ccc; border-radius: 10px; margin-top: 6px;}
</style>

<div class="search-wrap">
    <section class="search-item-wrap">
        <div>테스트 노드</div>

        <button onclick="addNode('T')">TC</button>
    </section>

    <section class="search-item-wrap">
        <div>컨트롤 노드</div>

        <button onclick="addNode('C')">IF</button>
    </section>

    <section class="search-item-wrap">
        <div>터미널</div>

        <button onclick="addNode('S')">시작</button>
        <button onclick="addNode('N')">정상 종료</button>
        <button onclick="addNode('E')">오류 종료</button>
    </section>

    <section class="search-item-wrap">
        <div>플로우라인</div>

        <button onclick="addLine()">라인</button>
    </section>

    <button onclick="removeNode()">삭제</button>
    <button onclick="saveNode()">저장</button>
</div>
<svg width="1000" height="800"></svg>
<div class="detail-wrap"></div>

<script src="http://d3js.org/d3.v4.min.js" charset="utf-8"></script>
<script>
    /*
     Resource Type
     T: 테스트 노드, C: 컨트롤 노드, S: 시작 터미널
     N: 정상종료 터미널, E: 오류종료 터미널, L: 플로우 라인
     */

    var svg = d3.select('svg'),
            svgWidth = svg.attr('width'),
            svgHeight = svg.attr('height'),
            widthCenter = svgWidth / 2,
            heightCenter = svgHeight / 2,
            widthList = {T: 80, C: 50, S: 50, N: 50, E: 50},
            heightList = {T: 60, C: 50, S: 50, N: 50, E: 50},
            colorList = {T: '#4F81BD', C: '#7F7F7F', S: '#7F7F7F', N: '#22d37f', E: '#FE3E02'},
            textXList = {T: 10, C: 14, S: 15, N: 15, E: 15},
            textYList = {T: 15, C: 40, S: 35, N: 35, E: 35},
            textSizeList = {T: 12, C: 30, S: 30, N: 30, E: 30},
            textList = {C: 'IF', S: 'S', N: 'N', E: 'E'};

    // arrow
    svg.append("defs")
            .selectAll("marker")
            .data(['arrow'])
            .enter().append("marker")
            .attr("id", function (d) {
                return d;
            })
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 11)
            .attr("refY", 0)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5");

    // ID Node Component
    var idNodeDef = svg.append("defs")
            .append('g')
            .attr('id', 'id-node');

    idNodeDef.append('rect')
            .attr('x', 45)
            .attr('y', -30)
            .attr('width', 60)
            .attr('height', 25)
            .attr('stroke', '#bbb')
            .attr('stroke-width', 1)
            .attr('stroke-dasharray', 5)
            .attr('rx', 5)
            .attr('ry', 5)
            .style('fill', 'transparent');

    // T Node Component
    var tNodeDef = svg.append("defs")
            .append('g')
            .attr('id', 't-node');

    tNodeDef.append('rect')
            .attr('width', widthList['T'])
            .attr('height', heightList['T'])
            .attr('stroke', colorList['T'])
            .attr('stroke-width', 2)
            .attr('rx', 10)
            .attr('ry', 10);

    tNodeDef.append('rect')
            .attr('x', 80)
            .attr('y', 15)
            .attr('width', 30)
            .attr('height', 30)
            .attr('fill', '#4F81BD')
            .attr('rx', 5)
            .attr('ry', 5);

    tNodeDef.append('text')
            .attr('x', 85)
            .attr('y', 35)
            .attr('fill', '#fff')
            .attr('font-size', 16)
            .attr('font-weight', 'bold')
            .text('TC');

    tNodeDef.append('use')
            .attr('xlink:href', '#id-node');

    // C Node Component
    var cNodeDef = svg.append("defs")
            .append('g')
            .attr('id', 'c-node');

    cNodeDef.append('path')
            .attr('stroke', colorList['C'])
            .attr('stroke-width', 2)
            .attr('d', d3.symbol().type(d3.symbolTriangle).size(1400));

    cNodeDef.append('use')
            .attr('xlink:href', '#id-node');

    // S Node Component
    var sNodeDef = svg.append("defs")
            .append('g')
            .attr('id', 's-node');

    sNodeDef.append('rect')
            .attr('width', widthList['S'])
            .attr('height', heightList['S'])
            .attr('stroke', colorList['S'])
            .attr('stroke-width', 2)
            .attr('rx', '50%')
            .attr('ry', '50%');

    sNodeDef.append('use')
            .attr('xlink:href', '#id-node');

    // N Node Component
    var nNodeDef = svg.append("defs")
            .append('g')
            .attr('id', 'n-node');

    nNodeDef.append('rect')
            .attr('width', widthList['N'])
            .attr('height', heightList['N'])
            .attr('stroke', colorList['N'])
            .attr('stroke-width', 2)
            .attr('rx', '50%')
            .attr('ry', '50%');

    nNodeDef.append('use')
            .attr('xlink:href', '#id-node');

    // E Node Component
    var eNodeDef = svg.append("defs")
            .append('g')
            .attr('id', 'e-node');

    eNodeDef.append('rect')
            .attr('width', widthList['E'])
            .attr('height', heightList['E'])
            .attr('stroke', colorList['E'])
            .attr('stroke-width', 2)
            .attr('rx', '50%')
            .attr('ry', '50%');

    eNodeDef.append('use')
            .attr('xlink:href', '#id-node');

    var graphData = {
        nodes: [
            {type: 'S', id: '0000'},
            {type: 'T', id: '0002'},
            {type: 'C', id: '0004'},
            {type: 'T', id: '0008', text: '0008입니다'},
            {type: 'T', id: '0009', text: '0009입니다'},
            {type: 'T', id: '000A', text: '000A입니다'},
            {type: 'T', id: '000E'},
            {type: 'N', id: 'FFFF'}
        ],
        links: [
            {source: '0000', target: '0002'},
            {source: '0002', target: '0004'},
            {source: '0004', target: '0008'},
            {source: '0004', target: '0009'},
            {source: '0004', target: '000A'},
            {source: '0008', target: '000E'},
            {source: '0009', target: '000E'},
            {source: '000A', target: 'FFFF'},
            {source: '000E', target: 'FFFF'}
        ]
    };

    // force layout
    var simulation = d3.forceSimulation()
            .force('link', d3.forceLink().id(function(d) { return d.id; })
                    .distance(300))
            .alphaTarget(1)
            .on('tick', ticked);

    var link = svg.append('g').attr('class', 'links').selectAll('.link');
    var text = svg.append('g').attr('class', 'texts').selectAll('.text');
    var node = svg.append('g').attr('class', 'nodes').selectAll('.node');
    var idText = svg.append('g').attr('class', 'idTexts').selectAll('.idText');

    var lineMode = false,
            linkSourceId = null,
            targetSourceId = null;

    var removeNodeId = null;

    updateNode();

    function updateNode() {
        link = link.data(graphData.links);

        link.exit().remove();

        link = link.enter()
                .append('path')
                .merge(link)
                .attr("marker-end", function () {
                    return "url(#arrow)";
                });


        node = node.data(graphData.nodes);

        node.exit().remove();

        node = node.enter()
                .append('use')
                .merge(node)
                .attr('xlink:href', function(d) {
                    return '#' + d.type.toLowerCase() + '-node';
                })
                .on('click', function(d) {
                    document.getElementsByClassName('detail-wrap')[0].innerHTML = d.id;

                    if(lineMode) {
                        drawLine(d.id);
                    }else{
                        removeNodeId = d.id;
                    }
                })
                .on('mouseover', function(){
                    d3.select(this).attr('stroke-width', 4)
                })
                .on('mouseout', function(){
                    d3.select(this).attr('stroke-width', 2)
                })
                .call(d3.drag()
                        .on('start', dragstarted)
                        .on('drag', dragged)
                        .on('end', dragended));

        text = text.data(graphData.nodes);

        text.exit().remove();

        text = text.enter()
                .append('text')
                .merge(text)
                .attr('x', function(d) {
                    return textXList[d.type];
                })
                .attr('y', function(d) {
                    return textYList[d.type];
                })
                .style('font-size', function(d) {
                    return textSizeList[d.type];
                })
                .style('fill', function(d) {
                    if(d.type !== 'T') {
                        return colorList[d.type];
                    }
                })
                .text(function (d) {
                    if(d.type !== 'T') {
                        return textList[d.type];
                    }

                    return d.text;
                })
                .call(d3.drag()
                        .on('start', dragstarted)
                        .on('drag', dragged)
                        .on('end', dragended));


        idText = idText.data(graphData.nodes);

        idText.exit().remove();

        idText = idText.enter()
                .append('text')
                .merge(idText)
                .attr('x', 55)
                .attr('y', -10)
                .text(function (d) {
                    return d.id;
                })
                .call(d3.drag()
                        .on('start', dragstarted)
                        .on('drag', dragged)
                        .on('end', dragended));

        simulation.nodes(graphData.nodes);
        simulation.force('link').links(graphData.links);

        setPosition();

        function dragstarted(d) {
            if (!d3.event.active) simulation.alphaTarget(0.3).restart();

            d.fx = d.x;
            d.fy = d.y;

            if(d.notLink) simulation.stop();
        }

        function dragged(d) {
            d3.select(this).dispatch('click');

            d.x = d.fx = d3.event.x;
            d.y = d.fy = d3.event.y;
        }

        function dragended(d) {
            if (!d3.event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;

            if(d.notLink) simulation.restart();
        }
    };

    function ticked() {
        node.attr('transform', function(d) {
            if(d.type === 'C') return 'translate(' + ( d.x+ 24 ) + ',' + (d.y + 32) + ')';

            return 'translate(' + d.x + ',' + d.y + ')'
        });
        text.attr('transform', function(d) { return 'translate(' + d.x + ',' + d.y + ')' });
        idText.attr('transform', function(d) {
            if(d.type === 'C') return 'translate(' + ( d.x+ 24 ) + ',' + (d.y + 32) + ')';

            return 'translate(' + d.x + ',' + d.y + ')'
        });

        link.attr("d", function(d) {
            var sourceX = d.source.x + 25,
                sourceY = d.source.y + heightList[d.source.type],
                targetX = d.target.x  + 25,
                targetY = d.target.y,
                diffX,
                diffY,
                diffDistance = 50,
                curveDistance = 50,
                points = 'M ' + sourceX + "," + sourceY + " ";

            diffX = sourceX - targetX;
            diffY = sourceY - targetY;

            // X 좌표의 차이가 diffDistance 보다 큰 경우 곡선 처리
            if(diffX > 0 && diffX > diffDistance || diffX < 0 && diffX < (-1 * diffDistance)) {

                points += 'C ' + sourceX + "," + (sourceY + curveDistance ) + " ";

                if(diffX > 0 && diffY > 0) {
                    points += ((sourceX + targetX) / 2 - curveDistance * 2) + "," + ((sourceY + targetY) / 2 + curveDistance) + " ";
                }else  if(diffX > 0 && diffY < 0) {
                    points += ((sourceX + targetX) / 2 - curveDistance * 2) + "," + ((sourceY + targetY) / 2 - curveDistance) + " ";
                }else  if(diffX < 0 && diffY > 0) {
                    points += ((sourceX + targetX) / 2 + curveDistance * 2) + "," + ((sourceY + targetY) / 2 + curveDistance) + " ";
                }else  if(diffX < 0 && diffY < 0) {
                    points += ((sourceX + targetX) / 2 + curveDistance * 2) + "," + ((sourceY + targetY) / 2 - curveDistance) + " ";
                }

                points += targetX + "," + targetY ;
            }else{
                points += 'L ' + targetX + "," + targetY ;
            }


            return points ;
        });
    }

    function addNode(code) {
        graphData.nodes.push({
            type: code,
            id: code + Math.floor((Math.random() * 1000) + 1),
            x: 10,
            y: 10,
            notLink: true
        });

        updateNode();
    };

    function addLine() {
        lineMode = true;
    };

    function drawLine(id) {
        if(!linkSourceId) {
            linkSourceId = id;
        }else if(!targetSourceId) {
            if(linkSourceId === id) {
                return;
            }

            targetSourceId = id;

            graphData.links.push({source: linkSourceId, target: targetSourceId});

            graphData.nodes.forEach(function(node){
                if(node.id === linkSourceId || node.id === targetSourceId) {
                    delete node.notLink;
                }
            });

            updateNode();

            linkSourceId = null;
            targetSourceId = null;
            lineMode = false;
        }
    }

    function saveNode() {
        console.dir(graphData);
    }

    function removeNode() {
        var newGraphData = {
            nodes: [],
            links: []
        };

        if(!removeNodeId) {
            alert('노드를 선택해주세요.');
            return;
        }

        graphData.nodes.forEach(function(node){
            if(node.id !== removeNodeId) {
                newGraphData.nodes.push({
                    type: node.type,
                    id: node.id,
                    text: node.text
                });
            }
        });

        graphData.links.forEach(function(link){
            if(link.source.id !== removeNodeId && link.target.id !== removeNodeId) {
                newGraphData.links.push({
                    source: link.source.id,
                    target: link.target.id
                });
            }
        });

        graphData = newGraphData;

        updateNode();
    }

    function setPosition() {
        var totalDepthList = {},
                maxWidthLength = 0,
                maxHeightLength = 0,
                halfHeightLength = 0,
                halfWidthLength = 0,
                startNodeId = '';

        // make depth object
        graphData.nodes.forEach(function(node) {
            if(node.type === 'S') {
                startNodeId = node.id;
            }
        });

        setDepth(startNodeId, 1);

        halfHeightLength = Math.ceil(maxHeightLength/2);

        for(var key in totalDepthList){
            if(totalDepthList.hasOwnProperty(key)){
                var depthList = totalDepthList[key],
                        depthListLength = depthList.length;

                halfWidthLength = Math.floor(depthListLength/2);

                // save max width length
                if(maxWidthLength < depthListLength) {
                    maxWidthLength = depthListLength;
                }

                // set xPos, yPos
                depthList.forEach(function(depthObj, idx){
                    depthObj.xPos = idx - halfWidthLength;
                    depthObj.yPos = key - halfHeightLength;
                });
            }
        }

        console.log(totalDepthList);

        // set position
        simulation
                .force("x", d3.forceX().x(function (d) {
                    return widthCenter + (d.xPos || 0)* svgWidth/maxWidthLength;
                }).strength(.3))
                .force("y", d3.forceY().y(function (d) {
                    return heightCenter + (d.yPos || 0) * svgHeight/maxHeightLength;
                }).strength(.3));


        function setDepth(id, depth) {
            if(maxHeightLength < depth) {
                maxHeightLength = depth;
            }

            graphData.nodes.forEach(function(node) {
                if(node.id === id) {
                    if(!totalDepthList[depth]) {
                        totalDepthList[depth] = [];
                    }

                    if(totalDepthList[depth].indexOf(node) === -1){
                        totalDepthList[depth].push(node);
                    }
                }
            });

            graphData.links.forEach(function(link) {

                if(link.source.id === id) {
                    setDepth(link.target.id, depth + 1);
                }

            });
        }
    }
</script>
